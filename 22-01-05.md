# 오늘 공부한 것

- Python
- 정보처리기사
- C

## Python 공부

### generator

- 루프의 반복 동작을 제어할 수 있는 루틴 형태
- yield 구문과 함께 사용한다.
- 함수 안에서 yield를 사용하면 제너레이터가 된다.

**코드**

```python
def get_natural_number():
    n = 0
    while True:
        n += 1
        yield n
get_natural_number()

---------------------------------------------------

def generator():
    yield 1
    yield 'string'
    yield True
g = generator()
g
next(g)
next(g)
next(g)
```

**출력결과**

```
<generator object get_natural_number at 0x10d0fd510>

---------------------------------------------------

<generator object generator at 0x10d0fd890>
1
'string'
True
```

### range

- 클래스 타입이다.
- 제너레이터 방식을 사용한다.

### enumerate

- 여러 가지 자료형을 인덱스를 포함한 enumerate 객체로 리턴하는 함수

**코드**

```python
a = [1,2,3,2,45,2,5]
a

--------------------------------------------------

enumerate(a)
list(enumerate(a))

--------------------------------------------------

for i, v in enumerate(a):
    print(i, v)
```

**출력결과**

```
[1, 2, 3, 2, 45, 2, 5]

--------------------------------------------------

<enumerate at 0x10f41e380>
[(0, 1), (1, 2), (2, 3), (3, 2), (4, 45), (5, 2), (6, 5)]

--------------------------------------------------

0 1
1 2
2 3
3 2
4 45
5 2
6 5
```

### // 나눗셈 연산자

- / 연산자: 일반적인 나누기 연산자
- // 연산자: 몫을 리턴하는 연산자
- % 연산자: 나머지를 리턴하는 연산자
- `divmod(x, y)` : 몫과 나머지를 한 번에 구하는 연산자.
    
    ```python
    >>> divmod(5, 3)
    (1, 2)
    ```
    

### print

- 코딩 테스트 시에 디버깅에 유용하게 사용되는 함수
    - 사실 거의 유일한 방법
    - 실무에서는 추천하지 않는 방법

### pass

**코드**

```python
class MyClass(object):
	def method_a(self):

	def method_b(self):
			print("Method B")

c = MyClass()
```

위의 코드는 아래와 같은 인덴트 오류가 발생한다.

**출력결과**

```
    def method_b(self):
      ^
IndentationError: expected an indented block
```

`method_a()` 가 아무런 처리를 하지 않았기 때문에 엉뚱하게 `method_b()` 에서 오류가 발생한다.

`pass` 는 이런 오류를 막는 역할을 한다.

```python
class MyClass(object):
	def method_a(self):
			# 여기에 pass 추가
			pass

	def method_b(self):
			print("Method B")

c = MyClass()
```

- `pass` 는 널 연산으로 아무것도 하지 않는 기능이다.

### locals

- 로컬 심볼 테이블 딕셔너리를 가져오는 메소드로 업데이트 또한 가능하다.
- 로컬에 선언된 모든 변수를 조회할 수 있는 강력한 명령어이다.
- 변수명을 일일이 찾아낼 필요 없이 로컬 스코프에 정의된 모든 변수를 출력하기 때문에 편리하다.

**코드**

```python
...
import pprint
pprint.pprint(locals())
...
```

**출력결과**

```
{'nums': [2, 7, 11, 15],
'pprint': <module 'pprint' from '/usr/lib/python3.8/pprint.py'>,
'self': <__main__.Solution object at 0x8f0994759d90>,
'target': 9}
```

`pprint` 로 출력하게 되면 보기 좋게 줄바꿈 처리를 해주기 때문에 가독성이 높다.

---

## 정보처리기사

### 소프트웨어 생명주기

- 폭포수 모형 (고전적 생명 주기 모형)
    - 타당성 검토→계획→요구 분석→설계→구현→테스트→유지보수
    - 선형적
    - 지금은 잘 안쓰임
- 프로토타입 모형
    - 시제품을 만들어 최종 결과물을 예측하는 모형
    - 요구 수집→빠른 설계→프로토타입 구현→고객 평가→프로토타입 수정→구현
- 나선형 모형 (점진적 모형)
    - 보헴이 제안한 것으로 폭포수의 장점 + 프로토타입의 장점 + 위험 분석 기능을 하는 모형
    - 나선을 따라 돌듯이 점진적으로 구현
    - 위험 관리 + 위험 최소화
    - 계획수립→위험 분석→개발 및 검증→고객 평가
- 애자일 모형
    - 고객의 요구사항 변화에 유연하게 대응하는 모형
    - 폭포수 모형과 달리 매우 유연한 모형
    - 스프린트 또는 이터레이션이라고 하는 짧은 개발 주기 반복
    - 애자일 선언

### 스크럼

- 팀이 중심이 되어 개발의 효율성
- 팀원 스스로가 팀을 구성 및 스스로 해결 가능해야 함
- 제품 책임자(PO), 스크럼 마스터(SM), 개발팀(DT) 로 이루어진 팀
- PO
    - 개발될 제품에 대한 이해도가 높고 요구사항을 책임지고 의사 결정할 사람 == 개발 의뢰자 or 사용자
    - 이해관계자들의 의견을 종합해 제품에 대한 요구사항을 작성
    - 백로그를 작성하며 우선순위 부여
    - 백로그에 스토리를 추가할 수는 있지만 스토리의 우선순위를 부여하는 것을 불가
    - 주기적으로 우선순위 추가 및 갱신
- SM
    - 스크럼이 잘 수행되도록 가이드 역할
    - 팀원 통제 XXXXXXX
    - 스크럼 회의 주관, 진행 사항 점검, 발생한 장애요소 공론화 후 처리
- DT
    - PO와 SM을 제외한 모든 팀원
    - 최대 7~8명이 적당
- 백로그 제작→스프린트 계획 회의→스프린트 수행 및 매일 스크럼 회의→스프린트 검토 회의→스프린트 회고
- 백로그
    - 제품 개발에 필요한 모든 요구사항을 우선순위에 따라 나열한 목록
    - 지속적인 업데이트
    - 사용자 스토리를 기반으로 릴리즈 계획 수립
- 스프린트 계획 회의
    - 백로그 중 이번 스프린트에서 수행할 작업을 대상으로 단기 일정 수립
    - Task 단위로 분할한 후 개발자 별로 수행할 작업 목록인 스프린트 백로그를 작성
- 스프린트
    - 실제 개발 작업
    - 보통 2~4주
    - Task를 대상으로 작업 시간을 추정한 후 개발 담당자에게 할당
    - 개발자가 원하는 Task를 직접 선별하는 것이 좋음
    - Task는 할 일, 진행 중, 완료 의 세 가지 상태를 갖는다.
- 일일 스크럼 회의
    - 약 15분 정도의 짧은 시간 동안 진행 상황 점검
    - 회의는 서서 진행
    - 남은 작업 시간은 소멸 차트에 표시
    - 발견된 장애 요소를 해결할 수 있도록 도와줌
- 스프린트 검토 회의
    - 사용자가 포함된 참석자 앞에서 테스트 수행
    - 스프린트 한 주당 한 시간 내에서 진행
    - PO는 피드백을 정리한 후 제품 백로그에 반영
- 스프린트 회고
    - 회고하며 정해놓은 규칙을 잘 준수했는지, 개선할 점은 없는 지 확인하고 기록
    - 스프린트가 끝난 시점에서 수행하거나 일정 주기로 수행

---

## C

### 부모 프로세스와 자식 프로세스의 변수

- 자식 프로세스에서 수정한 지역변수나 전역변수는 부모프로세스에서 적용되지 않는다.

**코드**

```c
#include <stdio.h>
#include <unistd.h>

int	g_x;

int main(void)
{
	int		x;
	pid_t	parents;
	pid_t	child;

	x = 0;
	g_x = 0;
	parents = getpid();
	fork();
	if (parents != getpid())
	{
		child = getpid();
		x++;
		g_x++;
		printf("child:   %d &x: %d x: %d &g_x: %d g_x: %d\n", child, &x, x, &g_x, g_x);
	}
	else
		printf("parents: %d &x: %d x: %d &g_x: %d g_x: %d\n", parents, &x, x, &g_x, g_x);
	return (0);
}
```

**출력결과**

```
parents: 21218 &x: 1830991560 x: 0 &g_x: 45989920 g_x: 0
child:   21220 &x: 1830991560 x: 1 &g_x: 45989920 g_x: 1

각 변수들의 주소값이 동일한데도 불구하고 값이 변화하지 않는다 왜 이러징
```

### 포인터 free 이슈

- 포인터가 첫 번째 주소가 아닌 다른 주소를 가리킬 때 `free()` 를 사용하면 abort 에러 발생
