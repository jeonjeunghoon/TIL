# 오늘 공부한 것

- 정보처리기사
- C - 42서울(미니셸)

## 정보처리기사

### XP(eXtreme Programming)

**XP란**

고객의 요구사항에 유연하게 대응하여 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법

- 짧고 반복적인 개발 주기, 단순한 설계 고객의 적극적인 참여를 통해 빠르게 소프트웨어 개발을 목표
- 릴리즈의 기간을 짧게 반복하면서 고객의 요구사항 반영에 대한 가시성을 높인다.
    - 릴리즈: 몇 개의 요구사항이 적용되어 부분적으로 기능이 완료된 제품을 제공하는 것을 말한다.
    - 가시성: 릴리즈 기간을 짧게 반복하면서 개발 과정에서 제품 소프트웨어의 일부 기능이 구현될 때마다 고객에게 이를 확인시켜주면, 고객은 요구사항이 잘 반영되고 있음을 직접적으로 알 수 있다는 의미
- 릴리즈 테스트마다 고객이 직접 참여 및 확인
- 소규모 인원의 개발 프로젝트에 효과적

5가지 핵심 가치: 의사소통, 단순성, 용기, 존중, 피드백

**XP 개발 프로세스**

1. 사용자 스토리(User Story)
2. 릴리즈 계획 수립(Release Planning)
3. 스파이크(Spike)
4. 이터레이션(Iteration)
5. 승인 검사(Acceptance Test, 인수 테스트)
6. 소규모 릴리즈(Small Release)

**XP의 주요 실천 방법**

- Pair Programming
- Collective Ownership
- Test-Driven Development
- Whole Team
- Continuous Integration
- Refactoring, Design Improvement
- Small Releases

## 현행 시스템 파악

**현행 시스템 파악 절차**

새로 개발하려는 시스템의 개발 범위를 명확히 설정하기 위해 다음의 것들을 파악한다.

1. 시스템의 구성과 제공 기능
2. 시스템 간의 전달 정보
3. 사용되는 기술 요소
4. 소프트웨어
5. 하드웨어
6. 네트워크

**시스템 구성 파악**

현행 시스템의 구성은 조직의 주요 업무를 담당하는 기간 업무와 이를 지원하는 지원 업무로 구분하여 기술한다.

**시스템 기능 파악**

현행 시스템의 기능은 단위 업무 시스템이 현재 제공하는 기능들을 주요 기능과 하부 기능, 세부 기능으로 구분하여 계층형으로 표시한다.

**시스템 인터페이스 파악**

현행 시스템의 인터페이스에는 단위 업무 시스템 간에 주고받는 데이터의 종류, 형식, 프로토콜, 연계 유형, 주기 등을 명시한다.

**아키텍처 구성 파악**

현행 시스템의 아키텍처 구성은 기간 업무 수행에 어떠한 기술 요소들이 사용되는지 최상위 수준에서 계층별로 표현한 아키텍처 구성도로 작성한다.

**소프트웨어 구성 파악**

소프트웨어 구성에는 단위 업무 시스템 별로 업무 처리를 위해 설치되어 있는 소프트웨어들의 제품명, 용도 라이선스 적용 방식, 라이선스 수 등을 명시한다.

**하드웨어 구성 파악**

하드웨어 구성에는 단위 업무 시스템들이 운용되는 서버의 주요 사양과 수량, 그리고 이중화의 적용 여부를 명시한다.

**네트워크 구성 파악**

네트워크 구성은 업무 시스템들의 네트워크 구성을 파악할 수 있도록 서버의 위치, 서버 간의 네트워크 연결 방식을 네트워크 구성도로 작성한다.

## C - 42서울(미니셸)

### 시그널이란?

특정 이벤트가 발생했을 때 프로세스에게 전달하는 신호. 즉 프로세스 끼리 서로 통신하기 위한 수단이다.

- 특정 이벤트: 연산 오류, 사용자의 프로그램 종료 요청, 자식 프로세스의 종료
- 인터럽트(interrupt)라고 부르기도 한다.

### 시그널의 종류

`kill -l` 혹은 `man signal`

shell 명령어를 통해 시그널의 종류를 확인할 수 있다.

`kill -l`

![스크린샷 2022-01-18 오후 4.04.44.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ea67b666-5ef1-4b69-aaaa-51c505163896/스크린샷_2022-01-18_오후_4.04.44.png)

`man signal`

![스크린샷 2022-01-18 오후 4.08.02.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d37872b8-641e-4ed9-a814-3650796f8ffa/스크린샷_2022-01-18_오후_4.08.02.png)

### 시그널 핸들러

시그널을 받은 프로세스는 다음 3가지 반응 중 하나의 액션을 취한다.

1. 프로세스 종료
2. 시그널 무시
3. 사용자가 지정한 핸들러 함수 호출

### rl_replace_line 함수 경로 찾기

`brew info readline` 명령어를 입력하면 어디에 설치되어 있는지 나온다.

### 대강 완성해본 시그널 핸들러

```c
void	sig_handler(int sig) // 시그널 핸들러 함수
{
	if (sig != SIGINT) // Ctrl + C 가 아닌 경우
		return ;
	g_exit_state = 1; // Ctrl + C 의 종료 코드
	printf("\n");
	rl_on_new_line();
	rl_replace_line("", 1);
	rl_redisplay(); // 새로운 명령프롬프트가 출력된다.
}

void	ft_signal(void)
{
	signal(SIGINT, sig_handler); // Ctrl + C
	signal(SIGQUIT, SIG_IGN); // Ctrl + \
}                           // SIG_IGN 함수로 들어온 시그널은 무시된다.
```
