# 21-01-28 (THU)

#### 1. DDA 알고리즘

#### 2. Bresenham 알고리즘

<br><br>

# DDA (Digital Differential Analyser)

    컴퓨터 그래픽에서 직선을 그릴 때 실수형 숫자를 사용하는 알고리즘이다.

#### 일차함수 y = ax +b 의 기울기(a)를 이용해 직선을 그리는 알고리즘이다.

## 알고리즘 진행 로직

### 1 - 1. |기울기| < 1

```c
x0 += 1;
y0 += a;
round(y0);

```

### 1 - 2. |기울기| ≥ 1

```c
x0 += 1/a;
y0 += 1;
round(x0);
```

### 2. 픽셀을 찍는다.

### 3. 위와 같은 과정을 반복해 직선을 그린다.

## 문제점

- 시간이 많이 걸린다: 부동소수점 계산을 해야 한다.
- 오차 발생 가능성: 긴 선분의 경우 부동소수점 연산의 오차가 누적되어 정확한 직선 경로를 벗어날 수도 있다.

<br><br>

# Bresenham의 직선 알고리즘

- DDA의 문제점을 해결할 수 있는 또 다른 직선 알고리즘이다.
- 정수만을 사용해 선을 빠르게 그릴 수 있다.
- 또한 오차가 없다.

## 알고리즘 진행 로직

### 기울기가 0과 1사이인 직선일 때 (1 이상일 경우엔 x와 y를 바꿔 생각하면 된다)

1. 기울기가 1보다 작다는 뜻은 **X의 증가량이 Y의 증가량 보다 크다**라는 뜻이다.

        x - x0 > y - y0

2. DDA 알고리즘에서 보았듯이 X가 1이 증가하면 Y는 기울기(m) 만큼 증가한다. (역의 관계도 성립된다.)

        x += 1; y += 1/m;

3. 그러나 이 방식은 정수만을 이용하기 때문에 Y를 기울기 만큼 더해줄 수 없다. 그 대신, Y에 **1을 더할지 말지 판단해야 한다.**
4. 판단하는 기준은 Y좌표와 Y-1좌표의 **중간점인 M을 기준점**으로 두어, **Y의 좌표가 M의 위에 있다면 1을 더해주면 되고, 반대로 Y의 좌표가 M의 밑에 있다면 Y의 변화는 없다.**
5. 위의 로직을 생각하며 수식을 작성해보겠다.

### 1. k번 째 점과 k+1번 째점

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled.png)

### 2. k번 째 픽셀 이후에 찍힐 픽셀의 x좌표, y좌표

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%201.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%201.png)

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%202.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%202.png)

혹은

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%203.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%203.png)

### 3. 함수를 만들기 위한 예시 선분 (xl, yl), (xr, yr)

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%204.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%204.png)

### 3. W와 H의 값

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%205.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%205.png)

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%206.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%206.png)

### 4. 판별에 사용될 함수 만들기

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%207.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%207.png)

x와 y에 각각 xl, yl을 넣어 b를 도출해내 다음과 같은 식을 완성한다.

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%208.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%208.png)

이제 위의 식에 (x, y)를 넣으면, (x, y)의 좌표가 직선 위에 존재하는지 혹은 선분의 위에 있는지 혹은 아래에 있는지 판별할 수 있다.

#### (x, y)가 직선 위에 있는 경우

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%209.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%209.png)

#### (x, y)가 직선 아래에 있는 경우

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2010.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2010.png)

### 5. 도출해낸 식을 함수F로 정리한다.

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2011.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2011.png)

#### (x, y)가 직선 위에 있는 경우

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2012.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2012.png)

#### (x, y)가 직선 아래에 있는 경우

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2013.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2013.png)

이제 F에 중간점 M을 넣으면 M이 직선의 위에 있는지 아래에 있는지 위의 판별식으로 판별이 가능하다.

#### (M)이 직선 위에 있는 경우

→ Y에 1을 더하지 않는다.

#### (M)이 직선 아래에 있는 경우

→ Y에 1을 더한다.

#### k+1번 째 좌표를 결정하기 위한 판별식

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2014.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2014.png)

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2015.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2015.png)

### 6. k+2번 째 좌표를 결정하기 위한 판별식

#### case 1

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2016.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2016.png)

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2017.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2017.png)

#### case 2

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2018.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2018.png)

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2019.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2019.png)

### 7. 판별식의 초기값 F(M1)

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2020.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2020.png)

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2021.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2021.png)

### 8. 다음 픽셀 위치의 결정 및 판별식 갱신

#### case 1

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2022.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2022.png)

픽셀 위치

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2023.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2023.png)

F ← F + 2H

#### case 2

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2024.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2024.png)

픽셀 위치

![21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2025.png](21-01-28%20(THU)%200bea51eb39dd4d6780942611dd7488c2/Untitled%2025.png)

F ← F + 2(H - W)