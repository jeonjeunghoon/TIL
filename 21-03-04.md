# 학습 목록

- [42서울] Cub3D - 텍스처 출력 오류 수정

<br><br>

# 학습 내용

## [42서울] Cub3D - 텍스처 출력 오류 수정

### 수정 전

<img width="1192" alt="운다" src="https://user-images.githubusercontent.com/64737872/109942385-7e342b00-7d17-11eb-9e34-65cadab059e8.png">

### 수정 후

<img width="1192" alt="안움" src="https://user-images.githubusercontent.com/64737872/109942368-783e4a00-7d17-11eb-8eb1-55ed51ebbf76.png">

    텍스처가 우는 듯이 출력되는 현상을 고쳐본다.

### 원인

텍스처의 y좌표를 찾는 과정에서 예외처리를 안한 것이 원인이었다. 윗 사진 처럼 렌더링 하는 그래픽의 크기가 윈도우 보다 클 때 예외처리를 해주어야 한다.

### 과정

본인은 수학적 사고가 약한 편이라 여러가지 시도(삽질)를 하면서 개발하는 편이지만, 실력이 좋은 개발자는 탄탄한 수학적 사고를 바탕으로 개발한다고 들었다.

그래서 수학적으로 생각해보기로 결심하고 우선 현상 원인을 분석해보았다. 원인을 분석해보니 렌더링 되어야 할 벽의 크기를 클리핑하긴 했지만, 벽에 적용해야 할 텍스처의 크기를 클리핑하지 않았던 것이 문제였다.

예를 들어 윗 사진 처럼 벽이 화면에 가려 나오는 상황이라 가정해보자. 이때 벽은 y좌표 0부터 시작해 렌더링하면 되지만, 텍스처는 y좌표 0부터 시작해 렌더링하면 윗 사진 같은 오류가 발생한다. 왜냐하면 벽이 화면에 가려진 만큼 텍스처도 y좌표의 이동이 필요하기 때문이다.

### 구체적 과정

1. 그래서 0과 클리핑하기 전의 벽의 시작 y좌표를 비교해 0보다 작을 때 작은 만큼의 크기를 add라고 한다.
2. 텍스처의 y좌표를 add만큼 더해주어 텍스처의 출력 시작점을 변경한다.

```c
int add = 0;

if (wall_start < 0)
	add = wall_start * -1;
// wall_start = 벽의 y좌표

wall_start = get_bigger(0, wall_start);
// wall_start 클리핑 (0보다 작은 수일 경우 0으로 치환)
for (int y = wall_start; y < wall_end; y++)
{
	ty = (int)((y - wall_start + add) * TH / wall_h);
	// ty = 텍스쳐의 y좌표
	...
}
```
